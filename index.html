<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>World Clock</title>

  <style>
    :root{
      --bg:#fff;
      --text:#0b0f1a;
      --muted:#667085;
      --border:#e5e7eb;
      --soft:#f6f7f9;
      --accent:#4f46e5;
      --accentSoft:rgba(79,70,229,.10);
      --danger:#ef4444;
      --radius:14px;
      --shadow:0 2px 10px rgba(16,24,40,.04);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg);
      color:var(--text);
      padding:28px 18px 44px;
    }
    body.marker-dragging{ cursor: ew-resize; user-select:none; }
    body.sorting{ cursor: grabbing; user-select:none; }

    .wrap{ max-width:980px; margin:0 auto; display:grid; gap:14px; }
    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    h1{ margin:0; font-size:20px; font-weight:650; letter-spacing:-.2px; }
    .subtitle{ margin:0; color:var(--muted); font-size:13px; line-height:1.4; }

    .card{
      background:#fff;
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:16px;
      box-shadow:var(--shadow);
    }
    header + .card{ margin-top:6px; }

    .rightHead{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
    }
    @media (max-width:760px){
      .rightHead{ align-items:flex-start; }
    }

    .btnrow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .controlsRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    button{
      font:inherit;
      padding:9px 11px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      cursor:pointer;
      transition:background .12s ease, border-color .12s ease, transform .05s ease;
      user-select:none;
      white-space:nowrap;
    }
    button:hover{ background:var(--soft); border-color:#d7dbe3; }
    button:active{ transform:translateY(1px); }

    .primary{
      border-color:rgba(79,70,229,.35);
      background:rgba(79,70,229,.08);
      color:var(--accent);
    }
    .primary:hover{
      background:rgba(79,70,229,.12);
      border-color:rgba(79,70,229,.45);
    }
    .danger{
      color:var(--danger);
      border-color:rgba(239,68,68,.25);
      background:rgba(239,68,68,.03);
    }
    .danger:hover{
      border-color:rgba(239,68,68,.40);
      background:rgba(239,68,68,.06);
    }
    #resetBtn{
      font-size:12px;
      padding:7px 11px;
    }
    #addBtn{
      font-size:12px;
      font-weight:650;
      padding:10px 11px;
    }

    .segmented{
      display:inline-flex;
      border:1px solid var(--border);
      border-radius:999px;
      overflow:hidden;
      background:#fff;
    }
    .segmented button{
      border:none;
      border-right:1px solid var(--border);
      border-radius:0;
      padding:7px 10px;
      font-size:12px;
      background:transparent;
      color:var(--muted);
    }
    .segmented button:last-child{ border-right:none; }
    .segmented button[aria-pressed="true"]{
      color:var(--accent);
      background:var(--accentSoft);
    }

    .locations{
      display:flex;
      flex-direction:column;
      gap:20px;
      padding: 6px 0 2px;
    }

    .loc{
      display:grid;
      grid-template-columns: 240px 1fr 84px;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 920px){
      .loc{ grid-template-columns: 1fr; gap:10px; }
    }

    .cityBlock{ display:flex; flex-direction:column; gap:6px; }
    .cityBlock{ align-self:center; }
    .city{
      font-weight:650;
      letter-spacing:-.2px;
      font-size:16px;
      line-height:1.15;
    }
    .cityTime{
      font-size:13px;
      color:var(--muted);
      line-height:1.2;
    }
    .mono{
      font-variant-numeric:tabular-nums;
      font-feature-settings:"tnum";
    }

    .stripWrap{ display:flex; flex-direction:column; gap:8px; }
    .strip{
      position:relative;
      height: 34px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: #f5f6f8;
      overflow:hidden;
      cursor: ew-resize;
      touch-action: none;
    }
    .fill{
      position:absolute;
      top:0; bottom:0;
      left:0;
      width:0%;
      background: rgba(79,70,229,.10);
      pointer-events:none;
    }

    .workBand{
      position:absolute;
      top:0; bottom:0;
      background: rgba(11,15,26,.045); /* very light work-hours shading */
      border-radius: 999px;
      pointer-events:none;
    }
    .workBand::before{
      content:"";
      position:absolute;
      left:8px;
      top:50%;
      width:18px;
      height:18px;
      transform:translateY(-50%);
      opacity:.28;
      background-repeat:no-repeat;
      background-size:18px 18px;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%230b0f1a' stroke-width='1.6' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='7' width='18' height='12' rx='2'/%3E%3Cpath d='M8 7V6a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1'/%3E%3Cpath d='M3 12h18'/%3E%3Cpath d='M9 12v2h6v-2'/%3E%3C/svg%3E");
    }
    .marker{
      position:absolute;
      top:-8px;
      height: 50px;
      width: 2px;
      background: var(--accent);
      border-radius: 999px;
      transform: translateX(-1px);
      pointer-events:none;
    }
    .markerDot{
      position:absolute;
      top: 50%;
      left: 50%;
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 999px;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 0 3px rgba(79,70,229,.12);
      pointer-events:none;
    }

    .selectedTime{
      font-size:12px;
      color:var(--muted);
    }
    .selectedTime .t{
      color: var(--text);
      font-weight:650;
    }

    .actions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      align-items:flex-start;
    }
    .iconBtn{
      width:34px;
      height:34px;
      padding:0;
      border-radius:10px;
      display:grid;
      place-items:center;
      font-size:18px;
      line-height:0;
    }
    .dragHandle{
      cursor: grab;
      color: var(--muted);
    }
    body.sorting .dragHandle{ cursor: grabbing; }

    .draggingRow{
      position: fixed !important;
      z-index: 9999;
      pointer-events: none;
      box-shadow: 0 12px 30px rgba(16,24,40,.12);
      border-radius: 12px;
      background: #fff;
      opacity: .98;
    }
    .placeholder{
      border-radius: 12px;
      background: var(--soft);
      border: 1px dashed #d7dbe3;
    }

    .hr{ height:1px; background:var(--border); margin:16px 0 14px; }

    .addRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:start;
    }
    @media (max-width:760px){
      .addRow{ grid-template-columns:1fr; }
    }

    .suggestWrap{ position:relative; }
    input[type="text"]{
      width:100%;
      padding:10px 11px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      outline:none;
    }
    input[type="text"]:focus{
      border-color: rgba(79,70,229,.55);
      box-shadow: 0 0 0 4px rgba(79,70,229,.10);
    }

    .suggestions{
      position:absolute;
      top: calc(100% + 8px);
      left:0;
      right:0;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      box-shadow: 0 12px 28px rgba(16,24,40,.08);
      overflow:hidden;
      z-index:50;
    }
    .suggestions.hidden{ display:none; }

    .sItem{
      padding:10px 11px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .sItem:hover{ background:var(--soft); }
    .sMain{ font-size:13px; color:var(--text); }
    .sSub{ font-size:12px; color:var(--muted); }

    .hint{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
    }

    .modal{
      position:fixed;
      inset:0;
      background:rgba(11,15,26,.38);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:120;
    }
    .modal.hidden{ display:none; }
    .modalCard{
      width:min(520px, 100%);
      background:#fff;
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:0 20px 40px rgba(16,24,40,.18);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .modalHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .modalTitle{
      font-size:14px;
      font-weight:650;
      letter-spacing:-.2px;
    }
    .modalActions{
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="top">
        <div>
          <h1>World Clock</h1>
          <p class="subtitle">Type a city to add it. Drag on any bar to move the shared marker.</p>
        </div>

        <div class="rightHead">
          <div class="controlsRow">
            <button id="resetBtn" class="danger" title="Clears all saved data">Reset</button>
            <div class="segmented" role="group" aria-label="Time format">
              <button id="fmt12" type="button" aria-pressed="true">12-hour</button>
              <button id="fmt24" type="button" aria-pressed="false">24-hour</button>
            </div>
          </div>
        </div>
      </div>
    </header>

    <section class="card">
      <div class="locations" id="locations"></div>

      <div class="hr"></div>

      <div class="addRow">
        <div class="suggestWrap">
          <input id="newCity" type="text" placeholder="Add a city (e.g., Monaco)" autocomplete="off" />
          <div id="suggestions" class="suggestions hidden"></div>
          <div class="hint" id="cityHint">Loading cities…</div>
        </div>
        <button class="primary" id="addBtn">Add</button>
      </div>
    </section>
  </div>

  <div id="tzModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="tzModalTitle" aria-hidden="true">
    <div class="modalCard">
      <div class="modalHead">
        <div class="modalTitle" id="tzModalTitle">Choose local timezone</div>
        <button class="iconBtn" id="tzModalClose" aria-label="Close">×</button>
      </div>
      <div class="suggestWrap">
        <input id="tzModalInput" type="text" placeholder="Search a city or timezone" autocomplete="off" />
        <div id="tzModalSuggestions" class="suggestions hidden"></div>
      </div>
      <div class="modalActions">
        <button id="tzModalCancel">Cancel</button>
        <button class="primary" id="tzModalSave">Update</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // -----------------------------
  // City DB
  // expects ./cities_plus_iana.json next to this html
  // -----------------------------
  let CITY_DB = []; // {city, tz, country?, pop?, q?}
  const cityHintEl = document.getElementById("cityHint");
  const suggestionsEl = document.getElementById("suggestions");
  const newCityEl = document.getElementById("newCity");

  function norm(s){
    return String(s || "").trim().toLowerCase().replace(/\\s+/g," ");
  }

  function safeTimeZone(tz){
    try{ new Intl.DateTimeFormat("en-US", { timeZone: tz }).format(new Date()); return true; }
    catch{ return false; }
  }

  function tzOffsetMinutes(tz, date = new Date()){
    try{
      const dtf = new Intl.DateTimeFormat("en-US", {
        timeZone: tz,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hourCycle: "h23"
      });
      const parts = Object.fromEntries(dtf.formatToParts(date).map(p => [p.type, p.value]));
      const utc = Date.parse(`${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}Z`);
      return Math.round((utc - date.getTime()) / 60000);
    }catch{
      return 0;
    }
  }

  function tzOffsetLabel(tz){
    const mins = tzOffsetMinutes(tz);
    const sign = mins >= 0 ? "+" : "-";
    const abs = Math.abs(mins);
    const h = Math.floor(abs / 60);
    const m = abs % 60;
    return `GMT${sign}${h}${m ? ":" + String(m).padStart(2, "0") : ""}`;
  }

  function cityFromTZ(tz){
    if (!tz) return "Local";
    const parts = String(tz).split("/");
    const last = parts[parts.length - 1] || tz;
    return last.replace(/_/g, " ");
  }

  function escapeHtml(str){
    return String(str || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  const regionNameLookup = (function(){
    try{
      if (Intl && typeof Intl.DisplayNames === "function"){
        const dn = new Intl.DisplayNames(["en"], { type: "region" });
        return (code) => dn.of(String(code || "").toUpperCase());
      }
    }catch{}
    return () => "";
  })();

  function displayCountry(c){
    const rawCountry = c.country ? String(c.country).trim() : "";
    const q = c.q ? String(c.q).trim() : "";
    const lastToken = q ? q.split(/\s+/).pop() : "";
    if (lastToken && /^[a-zA-Z]{2}$/.test(lastToken)){
      const name = regionNameLookup(lastToken);
      if (name) return name;
    }
    return rawCountry;
  }

  function optionText(c){
    const city = c.city;
    const country = displayCountry(c);
    const tz = c.tz;
    return country ? `${city}, ${country}` : `${city} (${tz})`;
  }

  async function loadCityDb(){
    try{
      cityHintEl.style.display = "";
      cityHintEl.textContent = "Loading cities…";
      const res = await fetch("./cities_plus_iana.json", { cache: "force-cache" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      if (!Array.isArray(data)) throw new Error("Bad JSON");

      CITY_DB = data
        .filter(x => x && typeof x.city === "string" && typeof x.tz === "string")
        .map(x => {
          const city = String(x.city).trim();
          const tz = String(x.tz).trim();
          const country = typeof x.country === "string" ? x.country.trim() : "";
          const pop = Number.isFinite(x.pop) ? x.pop : (parseInt(x.pop, 10) || 0);
          const q = (x.q ? String(x.q) : `${city} ${country} ${tz}`).toLowerCase();

          return {
            ...x,
            city,
            tz,
            country,
            pop,
            q,
            _option: optionText({city, tz, country, q}),
            _optionLower: norm(optionText({city, tz, country, q})),
            _cityLower: norm(city),
          };
        })
        .sort((a,b) => (b.pop||0) - (a.pop||0));

      cityHintEl.textContent = "";
      cityHintEl.style.display = "none";
    }catch{
      CITY_DB = [];
      cityHintEl.style.display = "";
      cityHintEl.textContent = "Couldn’t load cities_plus_iana.json. Make sure you’re using a local server and the JSON is in the same folder.";
    }
  }

  // -----------------------------
  // Autocomplete UI
  // -----------------------------
  function setupAutocomplete(inputEl, listEl){
    let pending = null;
    let debounceTimer = null;

    function hide(){
      listEl.classList.add("hidden");
      listEl.innerHTML = "";
      pending = null;
    }

    function show(items){
      if (!items.length){
        hide();
        return;
      }
      listEl.classList.remove("hidden");
      listEl.innerHTML = "";

      for (const c of items){
        const main = optionText(c);
        const sub = tzOffsetLabel(c.tz);

        const div = document.createElement("div");
        div.className = "sItem";
        div.innerHTML = `
          <div class="sMain">${escapeHtml(main)}</div>
          <div class="sSub">${escapeHtml(sub)}</div>
        `;
        div.addEventListener("mousedown", (e) => e.preventDefault()); // prevent blur
        div.addEventListener("click", () => {
          pending = c;
          inputEl.value = main;
          hide();
          // keep focus for quick Add/Enter
          inputEl.focus();
        });
        listEl.appendChild(div);
      }
    }

    function update(){
      if (!norm(inputEl.value)) {
        hide();
        return;
      }
      const items = rankMatches(inputEl.value);
      show(items);
    }

    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        hide();
      }
    });

    inputEl.addEventListener("input", () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        pending = null;
        update();
      }, 120);
    });

    inputEl.addEventListener("blur", () => {
      setTimeout(() => hide(), 120);
    });

    document.addEventListener("mousedown", (e) => {
      if (!listEl.contains(e.target) && e.target !== inputEl) {
        hide();
      }
    });

    return {
      hide,
      update,
      getPending: () => pending,
      clearPending: () => { pending = null; }
    };
  }

  function rankMatches(q){
    const query = norm(q);
    if (!CITY_DB.length) return [];

    // If empty, show top popular cities
    if (!query) return CITY_DB.slice(0, 10);

    const tokens = query.split(" ").filter(Boolean);
    const scored = [];

    for (const c of CITY_DB){
      const hay = (c.q || c._option).toLowerCase();

      // must include all tokens
      let ok = true;
      for (const t of tokens){
        if (!hay.includes(t)) { ok = false; break; }
      }
      if (!ok) continue;

      let score = 0;
      if (c._optionLower === query) score += 1_000_000;
      if (c._cityLower === query) score += 900_000;
      if (c._cityLower.startsWith(query)) score += 700_000;
      if (c._optionLower.startsWith(query)) score += 600_000;
      score += (c.pop || 0);

      scored.push({ c, score });
    }

    scored.sort((a,b) => b.score - a.score);
    return scored.slice(0, 10).map(x => x.c);
  }

  const addAutocomplete = setupAutocomplete(newCityEl, suggestionsEl);

  // -----------------------------
  // State + storage
  // -----------------------------
  const STORAGE_KEY = "world_clock_v4_citydb";

  function detectedTimeZone(){
    return Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
  }
  function defaultTimeFormat(){
    try{
      const hc = new Intl.DateTimeFormat(undefined, { hour:"numeric" }).resolvedOptions().hourCycle;
      if (hc && (hc.includes("23") || hc.includes("24"))) return "24";
    }catch{}
    return "12";
  }

  function loadState(){
    const guess = detectedTimeZone();
    const saved = localStorage.getItem(STORAGE_KEY);

    const base = { tz: guess };
    const settings = { timeFormat: defaultTimeFormat() };

    if (!saved) return { base, others: [], settings };

    try{
      const parsed = JSON.parse(saved);
      const baseTz = (parsed.base?.tz ?? guess);
      const safeBaseTz = safeTimeZone(baseTz) ? baseTz : guess;

      const others = Array.isArray(parsed.others) ? parsed.others : [];
      const normalizedOthers = others
        .map(o => (typeof o === "string" ? { id: crypto.randomUUID(), tz: o, label: cityFromTZ(o) } : o))
        .filter(o => o && typeof o.tz === "string" && typeof o.label === "string");

      return {
        base: { tz: safeBaseTz },
        others: normalizedOthers,
        settings: { timeFormat: (parsed.settings?.timeFormat === "24" ? "24" : "12") }
      };
    }catch{
      return { base, others: [], settings };
    }
  }

  let state = loadState();
  function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

  // -----------------------------
  // Formatting
  // -----------------------------
  function hour12Setting(){ return state.settings.timeFormat === "12"; }

  function fmtTime(date, tz){
    return new Intl.DateTimeFormat(undefined, {
      timeZone: tz,
      weekday: "short",
      hour: "2-digit",
      minute: "2-digit",
      hour12: hour12Setting()
    }).format(date);
  }

  function getMinuteInTz(date, tz){
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: tz,
      minute: "2-digit",
      hour: "2-digit",
      hourCycle: "h23"
    }).formatToParts(date);
    const m = parseInt(parts.find(p => p.type === "minute")?.value ?? "0", 10);
    return Number.isFinite(m) ? m : 0;
  }

  // -----------------------------
  // Work-hours shading (8:00–16:00 local time)
  // Computes segments within the next 24h window [now, now+24h)
  // -----------------------------
  const _zonedPartsCache = new Map();
  function getZonedParts(ts, tz){
    // Cache formatter per tz for performance
    let fmt = _zonedPartsCache.get(tz);
    if (!fmt){
      fmt = new Intl.DateTimeFormat("en-CA", {
        timeZone: tz,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hourCycle: "h23"
      });
      _zonedPartsCache.set(tz, fmt);
    }
    const parts = fmt.formatToParts(new Date(ts));
    const get = (t) => parseInt(parts.find(p => p.type === t)?.value ?? "0", 10);
    return {
      year: get("year"),
      month: get("month"),
      day: get("day"),
      hour: get("hour"),
      minute: get("minute"),
    };
  }

  function zonedTimeToUtcTimestamp(tz, y, m, d, hh, mm){
    // Iteratively adjust a UTC guess until its formatted parts match the target local time.
    // Converges quickly for normal timezone offsets and DST transitions.
    let ts = Date.UTC(y, m - 1, d, hh, mm, 0, 0);
    for (let i = 0; i < 4; i++){
      const p = getZonedParts(ts, tz);
      const want = Date.UTC(y, m - 1, d, hh, mm, 0, 0);
      const got  = Date.UTC(p.year, p.month - 1, p.day, p.hour, p.minute, 0, 0);
      const diffMin = (want - got) / 60000;
      if (Math.abs(diffMin) < 0.1) break;
      ts += diffMin * 60000;
    }
    return ts;
  }

  function computeWorkSegments(tz, nowMs){
    const windowEnd = nowMs + 86400000; // 24h
    const pNow = getZonedParts(nowMs, tz);

    // tomorrow's Y/M/D in calendar terms
    const tmr = new Date(Date.UTC(pNow.year, pNow.month - 1, pNow.day) + 86400000);
    const y2 = tmr.getUTCFullYear();
    const m2 = tmr.getUTCMonth() + 1;
    const d2 = tmr.getUTCDate();

    const intervals = [
      [zonedTimeToUtcTimestamp(tz, pNow.year, pNow.month, pNow.day, 8, 0),
       zonedTimeToUtcTimestamp(tz, pNow.year, pNow.month, pNow.day, 16, 0)],
      [zonedTimeToUtcTimestamp(tz, y2, m2, d2, 8, 0),
       zonedTimeToUtcTimestamp(tz, y2, m2, d2, 16, 0)],
    ];

    const segs = [];
    for (const [a, b] of intervals){
      const start = Math.max(a, nowMs);
      const end = Math.min(b, windowEnd);
      if (end <= start) continue;

      const leftPct = ((start - nowMs) / 86400000) * 100;
      const widthPct = ((end - start) / 86400000) * 100;
      segs.push({ leftPct, widthPct });
    }
    return segs.slice(0, 2);
  }

  // -----------------------------
  // Shared marker with snap-up to :00/:30
  // -----------------------------
  let offsetMinutes = 0;
  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

  function computeSnapOffsetRoundUp(rawMinutes){
    rawMinutes = clamp(rawMinutes, 0, 1440);
    if (rawMinutes <= 0) return 0;

    const baseTz = state.base.tz || detectedTimeZone();
    const now = new Date();
    const baseMinute = getMinuteInTz(now, baseTz);

    const rem = baseMinute % 30;
    const deltaToNext = (rem === 0) ? 30 : (30 - rem);

    if (rawMinutes <= deltaToNext) return clamp(deltaToNext, 0, 1440);

    const remaining = rawMinutes - deltaToNext;
    const k = Math.ceil(remaining / 30);
    const snapped = deltaToNext + 30 * k;
    return clamp(snapped, 0, 1440);
  }

  function referenceDate(){ return new Date(Date.now() + offsetMinutes * 60 * 1000); }
  function markerPercent(){ return (offsetMinutes / 1440) * 100; }

  // -----------------------------
  // UI refs
  // -----------------------------
  const locationsEl = document.getElementById("locations");
  const fmt12Btn = document.getElementById("fmt12");
  const fmt24Btn = document.getElementById("fmt24");
  const resetBtn = document.getElementById("resetBtn");
  const addBtn = document.getElementById("addBtn");
  const tzModalEl = document.getElementById("tzModal");
  const tzModalInputEl = document.getElementById("tzModalInput");
  const tzModalSuggestionsEl = document.getElementById("tzModalSuggestions");
  const tzModalCloseBtn = document.getElementById("tzModalClose");
  const tzModalCancelBtn = document.getElementById("tzModalCancel");
  const tzModalSaveBtn = document.getElementById("tzModalSave");

  const tzModalAutocomplete = setupAutocomplete(tzModalInputEl, tzModalSuggestionsEl);

  // Row refs for fast updates
  let rowRefs = [];

  function setFormatUI(){
    const is24 = state.settings.timeFormat === "24";
    fmt24Btn.setAttribute("aria-pressed", is24 ? "true" : "false");
    fmt12Btn.setAttribute("aria-pressed", !is24 ? "true" : "false");
  }

  function baseTzDisplay(){
    const baseTz = state.base.tz || detectedTimeZone();
    const match = CITY_DB.find(c => c.tz === baseTz);
    return match ? optionText(match) : baseTz;
  }

  function openTzModal(){
    tzModalEl.classList.remove("hidden");
    tzModalEl.setAttribute("aria-hidden", "false");
    tzModalInputEl.value = "";
    tzModalAutocomplete.clearPending();
    tzModalAutocomplete.update();
    setTimeout(() => tzModalInputEl.focus(), 0);
  }

  function closeTzModal(){
    tzModalEl.classList.add("hidden");
    tzModalEl.setAttribute("aria-hidden", "true");
    tzModalAutocomplete.hide();
  }

  function applyBaseTimezone(){
    const raw = tzModalInputEl.value.trim();
    if (!raw) return;

    let nextTz = null;
    if (safeTimeZone(raw)) {
      nextTz = raw;
    } else {
      const best = findBestFromInput(tzModalInputEl.value, tzModalAutocomplete.getPending());
      if (!best) {
        alert("No match found. Try adding a country (e.g., 'Monaco' or 'Monaco, Monaco').");
        return;
      }
      nextTz = best.tz;
    }

    state.base.tz = nextTz;
    saveState();
    offsetMinutes = (offsetMinutes === 0) ? 0 : computeSnapOffsetRoundUp(offsetMinutes);
    rebuild();
    updateRows();
    closeTzModal();
  }

  function updateRows(){
    const now = new Date();
    const ref = referenceDate();
    const pct = markerPercent();

    for (const r of rowRefs){
      const tz = r.tzGetter();
      const label = r.labelGetter();

      r.cityEl.textContent = label;

      if (!safeTimeZone(tz)){
        r.cityTimeEl.textContent = "";
        if (r.work1El) r.work1El.style.display = "none";
        if (r.work2El) r.work2El.style.display = "none";
        r.markerEl.style.left = "0%";
        r.fillEl.style.width = "0%";
        r.selectedEl.innerHTML = "";
        continue;
      }

      r.cityTimeEl.textContent = fmtTime(now, tz);

      // Work-hours shading (8:00–16:00 local) within the next 24h window
      const segs = computeWorkSegments(tz, now.getTime());
      const bands = [r.work1El, r.work2El];
      for (let i = 0; i < bands.length; i++){
        const el = bands[i];
        const seg = segs[i];
        if (!el) continue;
        if (!seg || seg.widthPct <= 0){
          el.style.display = "none";
          continue;
        }
        el.style.display = "";
        el.style.left = `${seg.leftPct}%`;
        el.style.width = `${seg.widthPct}%`;
      }

      r.markerEl.style.left = `${pct}%`;
      r.fillEl.style.width = `${pct}%`;

      r.selectedEl.innerHTML = `Selected: <span class="t mono">${fmtTime(ref, tz)}</span>`;
    }
  }

  // -----------------------------
  // Marker drag (shared across strips)
  // -----------------------------
  let isMarkerDragging = false;

  function setOffsetFromClientX(clientX, stripEl){
    const rect = stripEl.getBoundingClientRect();
    const x = clamp(clientX - rect.left, 0, rect.width);
    const pct = rect.width ? (x / rect.width) : 0;
    const raw = pct * 1440;
    offsetMinutes = computeSnapOffsetRoundUp(raw);
    updateRows();
  }

  function attachStripDrag(stripEl){
    stripEl.addEventListener("pointerdown", (e) => {
      if (document.body.classList.contains("sorting")) return;
      isMarkerDragging = true;
      document.body.classList.add("marker-dragging");
      stripEl.setPointerCapture(e.pointerId);
      setOffsetFromClientX(e.clientX, stripEl);
    });

    stripEl.addEventListener("pointermove", (e) => {
      if (!isMarkerDragging) return;
      setOffsetFromClientX(e.clientX, stripEl);
    });

    stripEl.addEventListener("pointerup", (e) => {
      if (!isMarkerDragging) return;
      isMarkerDragging = false;
      document.body.classList.remove("marker-dragging");
      try{ stripEl.releasePointerCapture(e.pointerId); }catch{}
    });

    stripEl.addEventListener("pointercancel", () => {
      isMarkerDragging = false;
      document.body.classList.remove("marker-dragging");
    });

    stripEl.addEventListener("click", (e) => {
      if (document.body.classList.contains("sorting")) return;
      setOffsetFromClientX(e.clientX, stripEl);
    });
  }

  // -----------------------------
  // Sorting (drag handle)
  // -----------------------------
  let sortState = null;

  function getOtherRows(){
    return Array.from(locationsEl.querySelectorAll('[data-row="other"]'));
  }

  function updateStateOrderFromDOM(){
    const byId = Object.fromEntries(state.others.map(o => [o.id, o]));
    const ids = getOtherRows().map(el => el.dataset.id);
    state.others = ids.map(id => byId[id]).filter(Boolean);
    saveState();
  }

  function startSorting(pointerEvent, rowEl, handleEl){
    if (!rowEl || rowEl.dataset.row !== "other") return;

    document.body.classList.add("sorting");

    const rect = rowEl.getBoundingClientRect();
    const offsetY = pointerEvent.clientY - rect.top;

    const placeholder = document.createElement("div");
    placeholder.className = "placeholder";
    placeholder.style.height = `${rect.height}px`;

    rowEl.parentNode.insertBefore(placeholder, rowEl);

    rowEl.classList.add("draggingRow");
    rowEl.style.width = `${rect.width}px`;
    rowEl.style.left = `${rect.left}px`;
    rowEl.style.top = `${rect.top}px`;

    rowEl.style.top = `${pointerEvent.clientY - offsetY}px`;

    sortState = { rowEl, placeholder, offsetY, pointerId: pointerEvent.pointerId };

    try{ handleEl.setPointerCapture(pointerEvent.pointerId); }catch{}
  }

  function findInsertBeforeElement(y, excludingEl){
    const rows = getOtherRows().filter(el => el !== excludingEl);
    let closest = null;
    let closestDist = Infinity;

    for (const r of rows){
      const rect = r.getBoundingClientRect();
      const mid = rect.top + rect.height / 2;
      const dist = Math.abs(y - mid);
      if (dist < closestDist){
        closestDist = dist;
        closest = r;
      }
    }
    return closest;
  }

  function moveSorting(pointerEvent){
    if (!sortState) return;
    const { rowEl, placeholder, offsetY } = sortState;

    rowEl.style.top = `${pointerEvent.clientY - offsetY}px`;

    const target = findInsertBeforeElement(pointerEvent.clientY, rowEl);
    if (!target) return;

    const targetRect = target.getBoundingClientRect();
    const before = pointerEvent.clientY < (targetRect.top + targetRect.height / 2);

    if (before) {
      if (placeholder.nextSibling !== target) locationsEl.insertBefore(placeholder, target);
    } else {
      if (target.nextSibling !== placeholder) locationsEl.insertBefore(placeholder, target.nextSibling);
    }
  }

  function endSorting(handleEl){
    if (!sortState) return;

    const { rowEl, placeholder, pointerId } = sortState;

    rowEl.classList.remove("draggingRow");
    rowEl.style.width = "";
    rowEl.style.left = "";
    rowEl.style.top = "";

    locationsEl.insertBefore(rowEl, placeholder);
    placeholder.remove();

    updateStateOrderFromDOM();

    sortState = null;
    document.body.classList.remove("sorting");

    try{ handleEl.releasePointerCapture(pointerId); }catch{}
  }

  // -----------------------------
  // Add city
  // -----------------------------
  function addLocation({ tz, label }){
    const cleanTz = String(tz || "").trim();
    const cleanLabel = String(label || "").trim();
    if (!cleanLabel || !cleanTz) return;

    if (!safeTimeZone(cleanTz)) {
      alert("That timezone isn’t supported by this browser.");
      return;
    }

    // Dedup by (label + tz) so SF and LA can both exist even though tz may match.
    const key = norm(cleanLabel) + "|" + norm(cleanTz);
    const exists = state.others.some(o => (norm(o.label) + "|" + norm(o.tz)) === key);
    if (exists) return;

    const id = crypto.randomUUID ? crypto.randomUUID() : String(Date.now() + Math.random());
    state.others.push({ id, tz: cleanTz, label: cleanLabel });
    saveState();

    rebuild();
    updateRows();
  }

  function findBestFromInput(inputValue, pending){
    const input = norm(inputValue);
    if (!input || !CITY_DB.length) return null;

    // If user previously clicked a suggestion that matches the current input, use it
    if (pending && norm(optionText(pending)) === input) return pending;

    // Exact option match
    const exactOpt = CITY_DB.find(c => c._optionLower === input);
    if (exactOpt) return exactOpt;

    // Exact city match if unique (prefer highest pop if multiple)
    const cityMatches = CITY_DB.filter(c => c._cityLower === input);
    if (cityMatches.length === 1) return cityMatches[0];
    if (cityMatches.length > 1) {
      cityMatches.sort((a,b) => (b.pop||0) - (a.pop||0));
      return cityMatches[0];
    }

    // Otherwise take the top ranked match
    const ranked = rankMatches(inputValue);
    return ranked[0] || null;
  }

  function addFromInput(){
    // Still allow direct IANA IDs
    const raw = newCityEl.value.trim();
    if (!raw) return;

    if (safeTimeZone(raw)) {
      addLocation({ tz: raw, label: cityFromTZ(raw) });
      newCityEl.value = "";
      addAutocomplete.hide();
      return;
    }

    const best = findBestFromInput(newCityEl.value, addAutocomplete.getPending());
    if (!best) {
      alert("No match found. Try adding a country (e.g., 'Monaco' or 'Monaco, Monaco').");
      return;
    }

    // Per your requirement: row label is only the city name
    addLocation({ tz: best.tz, label: best.city });

    newCityEl.value = "";
    addAutocomplete.hide();
  }

  // -----------------------------
  // Render
  // -----------------------------
  function rebuild(){
    locationsEl.innerHTML = "";
    rowRefs = [];

    function renderRow({ id, tz, label, isBase }){
      const row = document.createElement("div");
      row.className = "loc";
      row.dataset.id = id;
      row.dataset.row = isBase ? "base" : "other";

      const left = document.createElement("div");
      left.className = "cityBlock";

      const cityEl = document.createElement("div");
      cityEl.className = "city";
      cityEl.textContent = label;

      const cityTimeEl = document.createElement("div");
      cityTimeEl.className = "cityTime mono";
      cityTimeEl.textContent = "—";

      left.appendChild(cityEl);
      left.appendChild(cityTimeEl);

      const mid = document.createElement("div");
      mid.className = "stripWrap";

      const strip = document.createElement("div");
      strip.className = "strip";

      const work1 = document.createElement("div");
      work1.className = "workBand";
      const work2 = document.createElement("div");
      work2.className = "workBand";
      strip.appendChild(work1);
      strip.appendChild(work2);

      const fill = document.createElement("div");
      fill.className = "fill";
      strip.appendChild(fill);

      const marker = document.createElement("div");
      marker.className = "marker";
      const dot = document.createElement("div");
      dot.className = "markerDot";
      marker.appendChild(dot);
      strip.appendChild(marker);

      attachStripDrag(strip);

      const selected = document.createElement("div");
      selected.className = "selectedTime";
      selected.innerHTML = `Selected: <span class="t mono">—</span>`;

      mid.appendChild(strip);
      mid.appendChild(selected);

      const right = document.createElement("div");
      right.className = "actions";

      if (!isBase){
        const dragBtn = document.createElement("button");
        dragBtn.className = "iconBtn dragHandle";
        dragBtn.title = "Drag to reorder";
        dragBtn.textContent = "≡";
        dragBtn.setAttribute("aria-label", "Drag to reorder");

        dragBtn.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          startSorting(e, row, dragBtn);
        });

        dragBtn.addEventListener("pointermove", (e) => {
          if (!sortState) return;
          if (e.pointerId !== sortState.pointerId) return;
          e.preventDefault();
          moveSorting(e);
        });

        dragBtn.addEventListener("pointerup", (e) => {
          if (!sortState) return;
          if (e.pointerId !== sortState.pointerId) return;
          e.preventDefault();
          endSorting(dragBtn);
        });

        dragBtn.addEventListener("pointercancel", (e) => {
          if (!sortState) return;
          if (e.pointerId !== sortState.pointerId) return;
          endSorting(dragBtn);
        });

        const removeBtn = document.createElement("button");
        removeBtn.className = "iconBtn danger";
        removeBtn.title = "Remove";
        removeBtn.textContent = "×";
        removeBtn.addEventListener("click", () => {
          state.others = state.others.filter(o => o.id !== id);
          saveState();
          rebuild();
          updateRows();
        });

        right.appendChild(dragBtn);
        right.appendChild(removeBtn);
      } else {
        const moreBtn = document.createElement("button");
        moreBtn.className = "iconBtn";
        moreBtn.title = "Edit local timezone";
        moreBtn.textContent = "…";
        moreBtn.addEventListener("click", () => {
          openTzModal();
        });
        right.appendChild(moreBtn);
      }

      row.appendChild(left);
      row.appendChild(mid);
      row.appendChild(right);

      locationsEl.appendChild(row);

      rowRefs.push({
        tzGetter: () => tz,
        labelGetter: () => label,
        cityEl,
        cityTimeEl,
        markerEl: marker,
        work1El: work1,
        work2El: work2,
        fillEl: fill,
        selectedEl: selected
      });
    }

    const baseTz = state.base.tz || detectedTimeZone();
    renderRow({
      id: "base",
      tz: baseTz,
      label: cityFromTZ(baseTz),
      isBase: true
    });

    for (const o of state.others){
      if (!o?.tz || !o?.label) continue;
      renderRow({ id: o.id, tz: o.tz, label: o.label, isBase: false });
    }
  }

  // -----------------------------
  // Buttons + input events
  // -----------------------------
  fmt12Btn.onclick = () => {
    state.settings.timeFormat = "12";
    saveState();
    setFormatUI();
    updateRows();
  };
  fmt24Btn.onclick = () => {
    state.settings.timeFormat = "24";
    saveState();
    setFormatUI();
    updateRows();
  };

  addBtn.onclick = () => addFromInput();

  newCityEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      addFromInput();
    }
  });

  tzModalSaveBtn.onclick = () => applyBaseTimezone();
  tzModalCancelBtn.onclick = () => closeTzModal();
  tzModalCloseBtn.onclick = () => closeTzModal();
  tzModalEl.addEventListener("mousedown", (e) => {
    if (e.target === tzModalEl) closeTzModal();
  });
  tzModalInputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      applyBaseTimezone();
      return;
    }
    if (e.key === "Escape") {
      e.preventDefault();
      closeTzModal();
    }
  });

  resetBtn.onclick = () => {
    if (!confirm("Reset all saved locations?")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = loadState();
    offsetMinutes = 0;
    setFormatUI();
    rebuild();
    updateRows();
  };

  // -----------------------------
  // Init
  // -----------------------------
  if (!safeTimeZone(state.base.tz)) {
    state.base.tz = detectedTimeZone();
    saveState();
  }

  setFormatUI();
  rebuild();
  updateRows();
  loadCityDb(); // async
  setInterval(updateRows, 1000);
})();
</script>
</body>
</html>
